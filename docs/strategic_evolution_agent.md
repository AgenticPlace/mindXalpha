# Strategic Evolution Agent (SEA) (`strategic_evolution_agent.py`)

## Introduction

The `StrategicEvolutionAgent` (SEA) is a high-level autonomous agent within the MindX system (Augmentic Project). Its primary function is to orchestrate and manage **self-improvement campaigns** for the entire MindX system or significant parts thereof. It operates on broad strategic objectives (e.g., "Enhance system logging consistency," "Optimize performance of data processing modules").

The SEA achieves this by:
1.  Utilizing a `SystemAnalyzerTool` to scan the MindX codebase and leverage an LLM to identify specific, actionable improvement opportunities related to its current campaign goal.
2.  Employing an internal `BDIAgent` instance to manage the campaign as a series of Beliefs, Desires (goals), and Intentions (plans). The BDI agent's plan dictates the strategic steps of the campaign.
3.  Delegating tactical code modification tasks: When the BDI agent's plan requires a code change, the SEA makes a formal `COMPONENT_IMPROVEMENT` request to the main `CoordinatorAgent`.
4.  The `CoordinatorAgent` then invokes the specialized `SelfImprovementAgent` (SIA) via its CLI to perform the actual safe code modification and evaluation for the targeted file.
5.  The SEA receives the outcome from the Coordinator (which includes SIA's detailed report) and uses this to update its BDI agent's beliefs and potentially adjust the ongoing campaign strategy.

This architecture creates a hierarchical self-improvement process: strategic direction from SEA (via its BDI), tactical execution by SIA, and overall system orchestration by the Coordinator.

## Explanation

### Core Components & Workflow

1.  **Initialization (`__init__`):**
    *   Takes a unique `agent_id`, a reference to the shared `BeliefSystem`, and a crucial reference to the main `CoordinatorAgent`.
    *   Initializes its own `LLMHandler` for high-level strategic reasoning (though much reasoning is delegated to its internal BDI).
    *   Instantiates a `SystemAnalyzerTool`: This tool is used by the SEA (typically as part of a BDI action) to scan the codebase and use an LLM to generate concrete improvement suggestions (target files, descriptions, priorities).
    *   Instantiates an internal `BDIAgent`: This BDI agent is dedicated to the SEA's domain (e.g., `strategic_improvement_<SEA_agent_id>`). It manages the goals and plans for the *improvement campaign itself*.
    *   Registers custom BDI action handlers (`_sea_action_*` methods) that implement the strategic steps of an improvement campaign.
    *   Loads its own campaign history from a persistent JSON file.

2.  **Main Orchestration Method (`manage_improvement_campaign`):**
    *   This is the primary entry point when the SEA is tasked with a high-level improvement objective by the `CoordinatorAgent` or another supervising entity.
    *   It sets this objective as the primary goal for its internal `BDIAgent`.
    *   It then runs its `BDIAgent` for a configured number of cycles. The BDI agent's execution forms the core of the campaign.
    *   The final outcome of the BDI agent's run (e.g., campaign goal achieved, failed, timed out) is logged by the SEA and returned.

3.  **Internal BDI Agent's Role & Custom Strategic Actions:**
    The SEA's internal `BDIAgent` uses its perceive-deliberate-plan-execute cycle to manage the campaign. Its plans are generated by its own LLM (the BDI's `llm_handler`) and consist of strategic actions handled by the SEA:
    *   **`_sea_action_request_system_analysis(params)`**:
        *   Invokes `self.system_analyzer.analyze_system_for_improvements()` with a `focus_hint` (from BDI action params).
        *   The analyzer returns a list of detailed improvement suggestions.
        *   These suggestions are stored in the shared `BeliefSystem` under a key related to the BDI's current plan/goal, making them available for subsequent BDI actions.
    *   **`_sea_action_select_improvement_target(params)`**:
        *   Reads the list of suggestions from the `BeliefSystem` (populated by the previous analysis action).
        *   Selects one or more suggestions to pursue (e.g., based on priority given by the analyzer, or could use an LLM for more complex selection).
        *   Stores details of the *selected target(s)* in another belief.
    *   **`_sea_action_formulate_sia_task_goal(params)`**:
        *   Takes a single selected improvement target (from beliefs).
        *   Potentially uses an LLM to refine the `suggestion` from the analyzer into a more precise `improvement_description_for_sia` that is well-suited for the tactical `SelfImprovementAgent`.
        *   Outputs the formulated SIA task details (target path, precise goal for SIA, priority, criticality).
    *   **`_sea_action_request_coordinator_for_sia_execution(params)`**:
        *   Takes the formulated SIA task details.
        *   Calls `self.coordinator_agent.handle_user_input()` with `InteractionType.COMPONENT_IMPROVEMENT`.
        *   The `metadata` for this interaction includes the target component path, the precise improvement description for SIA, max SIA cycles, and any LLM overrides for SIA if specified by the SEA's plan.
        *   The `CoordinatorAgent` then invokes the SIA CLI.
        *   The full JSON response from SIA (relayed by the Coordinator) is stored in a `BeliefSystem` key related to the BDI's plan and the specific target.
    *   **`_sea_action_evaluate_sia_outcome(params)`**:
        *   Reads the SIA's outcome (the JSON response) from the `BeliefSystem`.
        *   If SIA reported success, this action can use the SEA's `llm_handler` to perform a higher-level *strategic critique* of the change based on the original suggestion, SIA's reported status, and potentially the diff patch provided by SIA. This assesses if the tactical change contributes to the SEA's strategic goal.
        *   Updates beliefs with this strategic evaluation.
    *   **`_sea_action_update_campaign_goal_status(params)`**:
        *   Assesses the overall status of the BDI's current strategic goal (e.g., the campaign goal) based on the outcomes of the SIA modifications and their evaluations.
        *   Updates the goal's status in the BDI agent's `GoalManager`. This can lead to the BDI agent selecting a new goal or concluding its run.
    *   The BDI agent's plan might loop through these actions for multiple identified opportunities or adjust its strategy based on the success/failure of tactical improvements.

4.  **Dynamic Parameter Resolution in BDI Plans (`_resolve_action_params` in BDI):**
    *   The BDI agent used by SEA is equipped to resolve action parameters dynamically. For example, the `REQUEST_COORDINATOR_FOR_SIA_EXECUTION` action in a BDI plan can have its `target_component_path` parameter set to `"$belief.strategic_evolution.<SEA_id>.plan.<plan_id>.selected_target.path"`, which would be resolved to the actual path chosen by a preceding `SELECT_IMPROVEMENT_TARGET` action.

5.  **History Management:**
    *   The SEA maintains its own `campaign_history` logging the high-level strategic campaigns it undertakes, their goals, and their final BDI outcomes. This is persisted to a JSON file specific to the SEA instance (e.g., `data/sea_campaign_history_strategic_evolver_001.json`).

### Layered Improvement Process

This creates a clear hierarchy for self-improvement:

1.  **External/User/Coordinator Directive:** A high-level improvement objective is given to the SEA (e.g., "Improve system efficiency").
2.  **SEA (Strategic Layer):**
    *   Sets this as a goal for its internal `BDIAgent`.
    *   BDI Agent plans strategic actions:
        *   Analyze relevant system parts (via `SystemAnalyzerTool`).
        *   Select specific, concrete improvement targets from the analysis.
        *   For each target, formulate a precise task for tactical execution.
        *   Request the `CoordinatorAgent` to execute this tactical task.
        *   Evaluate the outcome of the tactical execution.
        *   Update overall campaign goal status.
3.  **CoordinatorAgent (Orchestration Layer):**
    *   Receives tactical `COMPONENT_IMPROVEMENT` requests from the SEA.
    *   Manages its own backlog, applies HITL for critical targets (even if SEA thinks it's okay, Coordinator can have its own rules).
    *   Invokes the `SelfImprovementAgent` (SIA) CLI.
4.  **SelfImprovementAgent (SIA - Tactical Layer):**
    *   Executes the specific file modification as per the CLI command.
    *   Performs its internal Analyze->Implement->Evaluate(self-tests)->Promote cycle with all its safety features.
    *   Returns a detailed JSON report to the Coordinator.
5.  **Feedback Propagation:** Coordinator passes SIA's report back to SEA, which uses it to update its BDI's beliefs and continue its strategic campaign.

## Technical Details

-   **Asynchronous:** All core operations are `async`.
-   **Component-Based:** Composed of an internal `SystemAnalyzerTool` and an internal `BDIAgent`.
-   **Configuration:** Uses the global `Config` instance for its settings and to configure its sub-components.
-   **Belief System:** Deeply integrated with the shared `BeliefSystem` for storing analysis results, selected targets, SIA outcomes, and strategic evaluations.
-   **Decoupled Tactical Execution:** Crucially, the SEA *does not directly modify code*. It delegates this to the Coordinator -> SIA pipeline, ensuring that the robust safety mechanisms of the SIA are always in play for actual code changes.

## Usage

The `StrategicEvolutionAgent` is intended to be a long-running, highly autonomous agent within MindX, responsible for driving its evolution. It would typically be instantiated and given broad objectives by the main MindX application startup or by the `CoordinatorAgent` if the Coordinator is designed to delegate strategic initiatives.

```python
# --- Conceptual: How Coordinator might instantiate and task the SEA ---
# from mindx.learning.strategic_evolution_agent import StrategicEvolutionAgent

# async def main_system_startup():
#     # ... initialize Config, shared BeliefSystem ...
#     config = Config()
#     shared_bs = BeliefSystem()
#     coordinator = await get_coordinator_agent_mindx_async(config_override=config, test_mode=False) # Main coordinator

#     # Instantiate the Strategic Evolution Agent
#     sea = StrategicEvolutionAgent(
#         agent_id="mindx_strategist_v1",
#         belief_system=shared_bs,
#         coordinator_agent=coordinator, # SEA needs a reference to the Coordinator to delegate SIA calls
#         config_override=config
#     )
#     # Register SEA with Coordinator so it can be called if needed, or just let it run autonomously
#     coordinator.register_agent(sea.agent_id, "strategic_evolution_agent", "Handles long-term system evolution campaigns", [], instance=sea)

#     # Example: Tasking the SEA with a broad campaign goal
#     # This could be done via an Interaction sent to the SEA through the Coordinator,
#     # or by directly calling its manage_improvement_campaign method if appropriate.
#     if config.get("sea.run_initial_campaign_on_startup", False):
#         initial_campaign_goal = config.get("sea.initial_campaign_goal", "Proactively enhance overall system robustness and efficiency.")
#         logger.info(f"MAIN: Triggering initial campaign for SEA '{sea.agent_id}' with goal: {initial_campaign_goal}")
#         # Running it as a background task so startup isn't blocked
#         asyncio.create_task(sea.manage_improvement_campaign(initial_campaign_goal, max_bdi_run_cycles=50))
    
#     # ... rest of MindX application ...

#     # On shutdown
#     # await sea.shutdown()
#     # await coordinator.shutdown()
